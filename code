#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int GetMinrun(int n) //считаем minrun
{
    int r = 0;
    while (n >= 64)  //берутся старшие 6 бит из N и добавляется единица, если в оставшихся младших битах есть хотя бы один ненулевой
    {
        r |= n & 1;
        n >>= 1;
    }
    return n + r;
}

void Insertion(int *massiv, int start, int finish) //передаем в функцию исходный массив, индексы первого и конечного элементов подмассива
{
    for(int i=start;i<=finish;i++)
    {
        for(int j=i; j>start && massiv[j-1]>massiv[j];j--) //запускаем цикл в котором соседние элементы меняются местами , если элемент слева больше чем элемент справа
        {                                                  //причем движемся справа налево
            swap(massiv[j-1],massiv[j]);
        }
    }
}

void Merger(int *massiv, int st, int md, int fin)  //передаем в функцию исходный массив, индекс первого элемента левого подмассива , индекс границы между подмассивами , индекс конечного элемента правого подмассива
{
    int Length1=md-st+1;  //задаем размеры левого и правого подмассивов
    int Length2=fin-md;

    int left[Length1];  //создаем массивы из количества элементов , посчитанных ранее
    int right[Length2];

    for (int i=0; i<Length1; i++)
    {
        left[i]=massiv[st+i];  //заполняем левый поддмассив
    }

    for (int i=0; i<Length2; i++)
    {
        right[i] = massiv[md+1+i];   //заполняем правый подмассив
    }

    int i=0;  //инициализируем индексы для подмассивов
    int j=0;
    int k=st;  //индекс для исходного массива для дальнейшей работы с ним

    do
    {
        if (left[i] <= right[j])   //если  элемент левого подмассива меньше или равен  элементу правого подмассива
        {
            massiv[k] = left[i];  //то записываем в исходный массив элемент левого подмассива
            i++;                  //ставим указатель на следующий элемент левого подмассива для дальнейшего сравнения
        }
        else   //если  элемент левого подмассива больше элемента правого подмассива
        {
            massiv[k] = right[j];  //то записываем в исходный массив элемент правого  подмассива
            j++;                   //ставим указатель на следующий элемент правого  подмассива для дальнейшего сравнения
        }
        k++;       //ставим указатель на следующий элемент исходного массива для дальнейшего слияния
    }
    while (i<Length1 && j<Length2); //делаем это пока не подойдем к границе одного из двух подмассивов
    //если остались элементы , то
    while (i < Length1)  //если остались элементы левого подмассива , то копируем их и вставляем в конец отсортированного ранее исходного массива
    {
        massiv[k] = left[i];
        k++;
        i++;
    }

    while (j < Length2)  //если остались элементы правого  подмассива , то копируем их и вставляем в конец отсортированного ранее исходного массива
    {
        massiv[k] = right[j];
        k++;
        j++;
    }

}

void TimSort(int *massiv,int& Number,int& Minrun)  //передаем в функцию исходный массив, количество элементов и minrun
{
    for (int i=0; i<Number; i+=Minrun)
        Insertion(massiv,i,min((i+Minrun-1),(Number-1)));  //разбиваем массив на подмассивы и сортируем их вставками в функции Insertion

    for (int size=Minrun; size<Number ; size=2*size) //создаем цикл в котором после слияния меньших подмассивов будут сливаться дальнейшие объединенные подмассивы
    {
        for (int start=0; start<Number; start+=2*size) //создаем цикл в котором будут рассматриваться все время два соседних подмассива
        {                                             //start - начало левого подмассива
            int mid=start+size-1;  //граница между концом левого и началом правого подмассивов
            int finish=min((start+2*size-1),(Number-1)); //finish - конец правого подмассива
            Merger(massiv, start, mid, finish);    //сортируем подмассивы слиянием в функции Merger
        }
    }
}

int main()
{
    int N;
    cout << "Vvedite kolichestvo chisel massiva: ";
    cin >> N; //вводим количество чисел массива

    srand(time(NULL)); //это позволит функции rand() каждый раз генерировать именно случайные числа

    cout <<"vvedite massiv iz " << N <<" chisel: ";
    int *Massiv = new int[N]; //выделяем память под массив

    for(int i=0;i<N;i++)
    {
        Massiv[i]=rand()%100; //генерируем массив из случайных чисел в дипозоне от 0 до 99
        cout << Massiv[i] << " ";
    }
    int minrun=GetMinrun(N); //считаем minrun и передаем значение в переменную Minrun
    TimSort(Massiv,N,minrun);  // сортируем массив по алгоритму timsort

    cout <<endl<<endl<<"Sortirovka vipolnena: ";

    for(int i=0; i<N; i++)
    {
        cout << Massiv[i] << " ";  //выводим на экран весь исходный массив в результате работы алгоритма TimSort
    }
    cout<<endl;

    system("pause");

    return 0;
}
